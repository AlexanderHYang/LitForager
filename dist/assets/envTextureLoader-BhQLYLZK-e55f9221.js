import{t as O,c as D,a as E,_ as R,d as S,i as P,S as U,A as z,m as f}from"./index-c34e7bd4.js";const C="image/png",F=2,L=[134,22,135,150,246,214,150,54];function B(e){const o=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;for(let l=0;l<L.length;l++)if(o.getUint8(t++)!==L[l])return O.Error("Not a babylon environment map"),null;let r="",a=0;for(;a=o.getUint8(t++);)r+=String.fromCharCode(a);let n=JSON.parse(r);return n=v(n),n.specular&&(n.specular.specularDataPosition=t,n.specular.lodGenerationScale=n.specular.lodGenerationScale||.8),n}function v(e){if(e.version>F)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${F}".`);return e.version===2||(e={...e,version:2,imageType:C}),e}function I(e,o){o=v(o);const t=o.specular;let r=Math.log2(o.width);if(r=Math.round(r)+1,t.mipmaps.length!==6*r)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const a=new Array(r);for(let n=0;n<r;n++){a[n]=new Array(6);for(let l=0;l<6;l++){const u=t.mipmaps[n*6+l];a[n][l]=new Uint8Array(e.buffer,e.byteOffset+t.specularDataPosition+u.position,u.length)}}return a}function G(e,o,t){t=v(t);const r=t.specular;if(!r)return Promise.resolve();e._lodGenerationScale=r.lodGenerationScale;const a=I(o,t);return k(e,a,t.imageType)}function M(e,o,t,r,a,n,l,u,x,g,_){return new Promise((w,b)=>{if(t){const i=o.createTexture(null,!0,!0,null,1,null,s=>{b(s)},e);r?.onEffectCreatedObservable.addOnce(s=>{s.executeWhenCompiled(()=>{r.externalTextureSamplerBinding=!0,r.onApply=p=>{p._bindTexture("textureSampler",i),p.setFloat2("scale",1,o._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},o.scenes.length&&(o.scenes[0].postProcessManager.directRender([r],g,!0,n,l),o.restoreDefaultFramebuffer(),i.dispose(),URL.revokeObjectURL(a),w())})})}else{if(o._uploadImageToTexture(_,e,n,l),u){const i=x[l];i&&o._uploadImageToTexture(i._texture,e,n,0)}w()}})}async function k(e,o,t=C){if(!D.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const r=E(e.width)+1,a=e.getEngine();let n=!1,l=!1,u=null,x=null,g=null;const _=a.getCaps();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,a.updateTextureSamplingMode(3,e),_.textureLOD?a._features.supportRenderAndCopyToLodForFloatTextures?_.textureHalfFloatRender&&_.textureHalfFloatLinearFiltering?(n=!0,e.type=2):_.textureFloatRender&&_.textureFloatLinearFiltering&&(n=!0,e.type=1):n=!1:(n=!1,l=!0,g={});let w=0;if(n)a.isWebGPU?(w=1,await R(()=>import("./index-c34e7bd4.js").then(i=>i.h),["assets/index-c34e7bd4.js","assets/index-c34fb8f9.css"]).then(i=>i.Q)):await R(()=>import("./index-c34e7bd4.js").then(i=>i.h),["assets/index-c34e7bd4.js","assets/index-c34fb8f9.css"]).then(i=>i.N),u=new S("rgbdDecode","rgbdDecode",null,null,1,null,3,a,!1,void 0,e.type,void 0,null,!1,void 0,w),e._isRGBD=!1,e.invertY=!1,x=a.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,l){const i=e._lodGenerationScale,s=e._lodGenerationOffset;for(let p=0;p<3;p++){const m=1-p/2,d=s,T=(r-1)*i+s,h=d+(T-d)*m,A=Math.round(Math.min(Math.max(h,0),T)),y=new P(a,2);y.isCube=!0,y.invertY=!0,y.generateMipMaps=!1,a.updateTextureSamplingMode(2,y);const c=new U(null);switch(c._isCube=!0,c._texture=y,g[A]=c,p){case 0:e._lodTextureLow=c;break;case 1:e._lodTextureMid=c;break;case 2:e._lodTextureHigh=c;break}}}const b=[];for(let i=0;i<o.length;i++)for(let s=0;s<6;s++){const p=o[i][s],m=new Blob([p],{type:t}),d=URL.createObjectURL(m);let T;if(a._features.forceBitmapOverHTMLImageElement)T=a.createImageBitmap(m,{premultiplyAlpha:"none"}).then(h=>M(h,a,n,u,d,s,i,l,g,x,e));else{const h=new Image;h.src=d,T=new Promise((A,y)=>{h.onload=()=>{M(h,a,n,u,d,s,i,l,g,x,e).then(()=>A()).catch(c=>{y(c)})},h.onerror=c=>{y(c)}})}b.push(T)}if(o.length<r){let i;const s=Math.pow(2,r-1-o.length),p=s*s*4;switch(e.type){case 0:{i=new Uint8Array(p);break}case 2:{i=new Uint16Array(p);break}case 1:{i=new Float32Array(p);break}}for(let m=o.length;m<r;m++)for(let d=0;d<6;d++)a._uploadArrayBufferViewToTexture(e,i,d,m)}return Promise.all(b).then(()=>{x&&(a._releaseTexture(e),x._swapAndDie(e)),u&&u.dispose(),l&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))})}function H(e,o){o=v(o);const t=o.irradiance;if(!t)return;const r=new z;f.FromArrayToRef(t.x,0,r.x),f.FromArrayToRef(t.y,0,r.y),f.FromArrayToRef(t.z,0,r.z),f.FromArrayToRef(t.xx,0,r.xx),f.FromArrayToRef(t.yy,0,r.yy),f.FromArrayToRef(t.zz,0,r.zz),f.FromArrayToRef(t.yz,0,r.yz),f.FromArrayToRef(t.zx,0,r.zx),f.FromArrayToRef(t.xy,0,r.xy),e._sphericalPolynomial=r}class N{constructor(){this.supportCascades=!1}loadCubeData(o,t,r,a,n){if(Array.isArray(o))return;const l=B(o);if(l){t.width=l.width,t.height=l.width;try{H(t,l),G(t,o,l).then(()=>{t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),a&&a()},u=>{n?.("Can not upload environment levels",u)})}catch(u){n?.("Can not upload environment file",u)}}else n&&n("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}export{N as _ENVTextureLoader};
